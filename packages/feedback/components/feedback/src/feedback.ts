/**
 * @license
 *
 * Copyright IBM Corp. 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

import { LitElement, TemplateResult, html } from 'lit';
import { property, state } from 'lit/decorators.js';
import { v4 as uuidv4 } from 'uuid';
import HostListener from '@carbon/web-components/es/globals/decorators/host-listener';
import HostListenerMixin from '@carbon/web-components/es/globals/mixins/host-listener';

// @ts-ignore
import styles from './feedback.scss?inline';
import { FeedbackData } from '../defs';

/**
 * Feedback component to record and give feedback on AI generated content
 */
export class Feedback extends HostListenerMixin(LitElement) {
  static styles = styles;

  /**
   * Model ID or Model Name for which feedback is recording
   */
  @property({ attribute: 'model', type: String })
  private _model_id = '';

  /**
   * User Input to the model
   */
  @property({ attribute: 'input', type: String })
  private _input = '';

  /**
   * Output generated by AI Model
   */
  @property({ attribute: 'output', type: String })
  private _output = '';

  /**
   * ID generated For a particular input and output
   */
  @property({ attribute: 'generation-id', type: String, reflect: true })
  generation_id;

  @property()
  private feedbackList: FeedbackData[] = [];
  /**
   * State variable for Feedback Model
   */
  @state()
  private isModelOpen = false;

  /**
   * State variable for Edit selected text
   */
  @state()
  private isEditable = false;

  /**
   * To store data of selected text
   */
  @state()
  private selection;

  @state()
  private disableSave = false;

  @state()
  private isUpdateMode = false;

  @state()
  highlighted: TemplateResult | null = null;

  /**
   * Getter for selection
   */
  get Selection() {
    return this.selection;
  }

  /**
   * Object for recording the feedback
   */
  @state()
  private formData: FeedbackData = {
    feedback_id: '',
    generation_id: '',
    start_index: 0,
    end_index: 0,
    selected_text: '',
    suggested_text: '',
    feedback_type: [],
    comment: '',
  };

  /**
   * Array for storing checkbox values selected by user
   */
  private _feedbacks: string[] = [];
  private pageX = 0;
  private pageY = 0;

  /**
   * For Mounting the web component
   */
  connectedCallback(): void {
    super.connectedCallback();
    if (this._model_id && (this._input || this._output)) {
      const event = new CustomEvent('on-generation', {
        detail: {
          message: 'generated content',
          data: {
            id: this.generation_id,
            input_value: this._input,
            output_value: this._output,
            model: this._model_id,
          },
        },
      });
      this.dispatchEvent(event);
    }
    window.addEventListener('mousedown', () => {
      this.selection = null;
    });
  }

  /**
   * Click event handler that is attached to this component to get the selection / selected text
   * @param {Event} e Event from elements
   * @private
   */
  @HostListener('mouseup')
  _handleTextSelection(e) {
    if (this.isModelOpen) {
      // this.selectionMode = false;
      this.selection = null;
      return;
    }
    this.pageX = e.pageX;
    this.pageY = e.pageY;
    const selection = window.getSelection();

    this.selection = selection;
    const selectedText = selection?.toString().trim();

    if (selectedText && selection) {
      this.resetFeedbackForm();
      const minOffset = Math.min(selection.anchorOffset, selection.focusOffset);
      const maxOffset = Math.max(selection.anchorOffset, selection.focusOffset);
      this.formData.generation_id = this.generation_id;
      this.formData.selected_text = selectedText;
      this.formData.start_index = minOffset;
      this.formData.end_index = maxOffset;
      this.requestUpdate();
    } else {
      this.selection = null;
    }
  }

  /**
   * Input event handler that is attached to the feedback (corrected value) form input
   *
   * @param {object} event Event object of the corrected value from input box
   * @param {object} event.target input element
   * @private
   */
  _handleTextInput({ target }: Event) {
    const { value } = target as HTMLInputElement;
    this.formData.suggested_text = value;
  }

  /**
   * Input event handler that is attached to the feedback (comments) form input
   *
   * @param {object} event Event object of the corrected value from input box
   * @param {object} event.target input element
   * @private
   */
  _handleTextArea(event) {
    this.formData.comment = event?.target.value;
    if (this.formData.comment !== '') {
      this.disableSave = false;
    } else {
      this.disableSave = true;
    }
  }

  /**
   * Submit/Record the feedback data to backend
   * @private
   */
  _handleFormData() {
    if (this.isUpdateMode) {
      this.feedbackList = this.feedbackList.map((item) => {
        if (item.feedback_id === this.formData.feedback_id) {
          return { ...item, ...this.formData };
        }
        return item;
      });
    } else {
      if (!this.formData.feedback_id) {
        this.formData.feedback_id = uuidv4();
      }
      if (!this.formData.suggested_text) {
        this.formData.suggested_text = this.formData.selected_text;
      }
      this.feedbackList.push(this.formData);
    }

    const event = new CustomEvent('on-feedback-save', {
      detail: this.formData,
    });

    this.dispatchEvent(event);

    this.selection = null;
    this.resetFeedbackForm();
    this._feedbacks = [];
    this.isModelOpen = false;
    this.requestUpdate('feedbackList', []);
  }

  /**
   *
   * @param {FeedbackData} data Feedback Object
   */
  handleFeedbackUpdate(data: FeedbackData) {
    const {
      comment,
      end_index,
      feedback_id,
      feedback_type,
      generation_id,
      selected_text,
      start_index,
      suggested_text,
    } = data;
    this.formData.feedback_id = feedback_id;
    this.formData.generation_id = generation_id;
    this.formData.selected_text = selected_text;
    this.formData.suggested_text = suggested_text;
    this.formData.feedback_type = feedback_type;
    this.formData.start_index = start_index;
    this.formData.end_index = end_index;
    this.formData.comment = comment;

    this.isUpdateMode = true;
    this.isModelOpen = true;
  }

  /**
   * Checkbox Input event handler that is attached to the feedback form input
   *
   * @param {object} event Event object of the corrected value from input box
   * @param {object} event.target input element
   * @private
   */
  _handleFeedback(event) {
    const feedback = event.target.value;
    if (!this.formData.feedback_type.includes(feedback)) {
      this.formData.feedback_type.push(feedback);
    } else {
      this.formData.feedback_type = this.formData.feedback_type.filter(
        (item) => item != feedback
      );
    }
    this.disableSave = this.formData.feedback_type.includes('OTHER');
  }

  /**
   * Method for toggling the Feedback Modal
   */
  _toggle() {
    this.isModelOpen = !this.isModelOpen;
    this.isUpdateMode = false;
  }

  /**
   * Method for toggling improved text field
   */
  _toggleEdit() {
    this.isEditable = !this.isEditable;
  }

  /**
   *
   * @param {string} id feedback id
   *
   */
  handleFeedbackDelete(id) {
    this.feedbackList = this.feedbackList.filter(
      (item) => item.feedback_id !== id
    );
    const event = new CustomEvent('on-feedback-delete', {
      detail: { feedback_id: id },
    });
    this.dispatchEvent(event);
  }

  /**
   *
   */
  resetFeedbackForm() {
    this.formData = {
      feedback_id: '',
      generation_id: '',
      start_index: 0,
      end_index: 0,
      selected_text: '',
      suggested_text: '',
      feedback_type: [],
      comment: '',
    };
  }

  @state()
  private textPositions: any[] = [];

  /**
   *
   */
  calculateTextPosition() {
    const slotElement = this.shadowRoot?.querySelector('slot');
    const assignedNodes = slotElement?.assignedNodes({ flatten: true });
    const textNode = assignedNodes?.find(
      (node) =>
        node.nodeType === Node.TEXT_NODE && node.textContent?.trim() !== ''
    );

    const positions: any[] = [];
    this.textPositions = [];
    if (textNode) {
      for (const { start_index, end_index } of this.feedbackList) {
        const range = document.createRange();
        range.setStart(textNode, start_index);
        range.setEnd(textNode, end_index);
        const rect = range.getBoundingClientRect();
        positions.push(rect);
        this.textPositions.push(rect);
      }
    }
    this.textPositions = positions;
    return positions;
  }

  /**
   *
   * @param {FeedbackData} feedback feedback object
   */
  highlightedText(feedback: FeedbackData) {
    const text = this._output;
    const { start_index, end_index } = feedback;
    if (
      text &&
      start_index >= 0 &&
      end_index <= text.length &&
      end_index > start_index
    ) {
      const beforeHighlight = text.substring(0, start_index);
      const highlightedText = text.substring(start_index, end_index);
      const afterHighlight = text.substring(end_index);

      this.highlighted = html`${beforeHighlight}<span
          class="highlight-selection"
          >${highlightedText}</span
        >${afterHighlight}`;
    }
  }

  /**
   * To Reset the higlighted text
   */
  resetHiglightedText() {
    this.highlighted = null;
  }
}
